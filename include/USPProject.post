#
# "THE BEER-WARE LICENSE" (Revision CS-42):
#
# This file was written by the CodeShop developers.  As long as you
# retain this notice you can do whatever you want with it.
# If we meet some day, and you think this file is worth it, you can
# buy us a beer in return.  Even if you do that, this file still
# comes WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#

#
# $(call check-prereqs,<project>,<depending project*>)
#
# Checks the prerequisites of a project.
#
check-prereqs = $(strip \
  $(foreach pre,$($1.prereqs), \
    \
    $(call REM,check if prereq exists) \
    $(if $(filter-out $(all-projects),$(pre)), \
      $(error prerequisite project '$(pre)' in project '$1' not found) \
    ) \
    \
    $(call REM,check for project dependency cycles) \
    $(if $(filter $1 $2,$(pre)), \
      $(error $(strip \
        project cycle in project prereq chain \
        $(foreach proj,$(call reverse,$1 $2), \
          '$(proj)' -> \
        ) \
        '$(pre)' \
      )) \
    ) \
    \
    $(call REM,remove prereq from all-leaf-projects) \
    $(eval all-leaf-projects := $(filter-out $(pre),$(all-leaf-projects))) \
    \
    $(call REM,recurse over prereq) \
    $(call check-prereqs,$(pre),$(strip $1 $2)) \
  ) \
)
      
#
# $(call proj-with-pkg,<project>)
#
# For error reporting purposes.
#
proj-with-pkg = $(strip \
  '$1' \
  $(if $($1.package), \
    $(open-paren)package: '$($1.package)'$(close-paren) \
  ) \
)

#
# $(call is-prereq,<project>,<of project>*)
#
# Tells if <project> is a prereq of any project in <of project>*.
#
is-prereq = $(strip \
  $(if $(firstword $2), \
    $(if $(filter $(foreach of,$2,$($(of).prereqs)),$1), \
      \
      $(call REM,direct prereq found) \
      yes \
    , \
      $(call REM,check the prereqs' prereqs) \
      $(call is-prereq,$1,$(foreach of,$2,$($(of).prereqs))) \
    ) \
  ) \
)
    
#
# $(call contains-prereq,<project>*,<of project>)
#
# Tells if a list of projects contains a prereq of some other project
#
contains-prereq = $(strip \
  $(if $(firstword $1), \
    $(if $(call is-prereq,$(firstword $1),$2), \
      \
      $(call REM,prereq found at head of list) \
      yes \
    , \
      \
      $(call REM,check rest of list) \
      $(call contains-prereq,$(wordlist 2,$(words $1),$1),$2) \
    ) \
  ) \
)

#
# $(call remove-depending,<project *>,<on project>)
#
# Returns a new list of projects with projects depending on some
# specific projects removed
#
remove-depending = $(strip \
  $(foreach proj,$1, \
    $(if $(call is-prereq,$2,$(proj)), \
      \
      $(call REM,skip proj) \
    , \
      $(call REM,keep proj) \
      $(proj) \
    ) \
  ) \
)

#
# $(call add-packager,<packager *>,<new packager>)
#
# Adds a packager to a set of potential packagers for a project,
# returning the new set.
#
add-packager = $(strip \
  $(if $(filter $1,$2), \
    \
    $(call REM,already there so return old set) \
    $1 \
  , \
    $(if $(call contains-prereq,$1,$2), \
      \
      $(call REM,prereqs take priority so return old set) \
      $1 \
    , \
      \
      $(call REM,add after removing any depending packagers from set) \
      $2 $(call remove-depending,$1,$2) \
    ) \
  ) \
)
      
#
# $(call add-packagers,<project>,<depending project>*,<packager>?)
#
# Sets the potential packagers for <project> and its prereqs.
#
add-packagers = $(strip \
  \
  $(if $($1.distributable), \
    $(call REM,distributables can be packaged) \
    \
    $(if $($1.package), \
      $(call REM,project is its own packager) \
      \
      $(if $(filter-out $($3.package),$($1.package)), \
        $(call REM,switching package name) \
        \
        $(if $(filter $(foreach dep,$2,$($(dep).package)),$($1.package)), \
          $(call REM,re-entering previously visited package) \
          \
          $(error $(strip \
            package cycle in project prereq chain \
            $(foreach proj,$(call reverse,$2), \
              $(call proj-with-pkg,$(proj)) -> \
            ) \
            $(call proj-with-pkg,$1) \
          )) \
        ) \
      ) \
      $(eval $1.packagers := $1) \
    , \
      $(call REM,add depending packager if available) \
      \
      $(if $(strip $3), \
        $(eval $1.packagers := $(call add-packager,$($1.packagers),$3)) \
      ) \
    ) \
  , \
    $(call REM,not distributable) \
    \
    $(if $($1.package), \
      $(error $(strip \
        project '$1' cannot have a package because it is not distributable \
      )) \
    ) \
    $(eval $1.packagers :=) \
  ) \
  \
  $(call REM,visit prereqs) \
  \
  $(foreach pre,$($1.prereqs), \
    $(call add-packagers,$(pre),$(strip $1 $2),$(if $($1.package),$1,$3)) \
  ) \
)

#
# $(call potential-packages,<project>)
#
# Gets the potential packages for <project> by fetching the packages
# from its packagers.
#
potential-packages = $(strip \
  $(call dedup,$(foreach pkgr,$($1.packagers),$($(pkgr).package))) \
)

#
# $(call set-package-impl,<project>,<potential package*>)
#
set-package-impl = $(strip \
  $(if $(filter 0,$(words $2)), \
    $(call REM,no package) \
    \
    $(eval $1.package :=) \
  , \
    $(if $(filter 1,$(words $2)), \
      $(call REM,single package) \
      \
      $(eval $1.package := $(firstword $2)) \
      $(eval all-packages := $(call set-add,$(all-packages),$(firstword $2))) \
    , \
      $(call REM,multiple packages) \
      \
      $(error $(strip \
        cannot implicitly determine the package for project '$1' because \
        not all packaged projects depending on this project \
        [$(foreach pkgr,$($1.packagers),$(call proj-with-pkg,$(pkgr)))] \
        are in the same package \
      )) \
    ) \
  ) \
)

#
# $(call set-package,<project>)
#
set-package = $(call set-package-impl,$1,$(call potential-packages,$1))

#
# $(call projects-in-package,<package>)
#
projects-in-package = $(strip \
  $(foreach proj,$(all-projects), \
    $(if $(filter $1,$($(proj).package)), \
      $(proj) \
    ) \
  ) \
)

#
# $(call package-target,<package>)
#
define package-target =
.PHONY: $1.package
$1.package: $(foreach proj,$(call projects-in-package,$1),$(proj).package-project)

endef

#
# Check the prerequisites for all projects, so we know they form
# a proper dependency DAG without dangling project references.
# As a side effect, prerequisite projects are filtered out of
# $(all-leaf-projects).
#
all-leaf-projects := $(all-projects)
$(foreach proj,$(all-projects),$(call check-prereqs,$(proj)))

#
# Starting from the leaf projects in the tree, for each project,
# establish a list of (zero or more) packagers while removing
# packagers that depend on one of the project's other packagers.  (A
# packager is a project with an explicit 'package' attribute.)
#
$(foreach proj,$(all-projects),$(eval $(proj).packagers :=))
$(foreach proj,$(all-leaf-projects),$(call add-packagers,$(proj)))

#
# For each project, determine the package it is in (if any) by
# inspecting its list of packagers.  As a side effect, the list of all
# packages is established.
#
all-packages :=
$(foreach proj,$(all-projects),$(call set-package,$(proj)))

#
# For each package, define a '<package>.package' target
#
$(strip \
  $(foreach pkg,$(all-packages), \
    $(call expand,$(call package-target,$(pkg))) \
  ) \
)

.PHONY: all.package
all.package: $(foreach pkg,$(all-packages),$(pkg).package) 

PHONY: clean
clean:
	$(usp-rm-rf) "$(call to-shell,$(build-dir))"

