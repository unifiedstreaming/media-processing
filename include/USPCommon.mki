#
# "THE BEER-WARE LICENSE" (Revision CS-42):
#
# This file was written by the CodeShop developers.  As long as you
# retain this notice you can do whatever you want with it.
# If we meet some day, and you think this file is worth it, you can
# buy us a beer in return.  Even if you do that, this file still
# comes WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#

#
# Determine the name of this directory
#
this-dir := $(abspath $(dir $(lastword $(MAKEFILE_LIST))))
top-dir := $(abspath $(this-dir)/..)

#
# Some common settings and utilities
#

DEFAULT_GOAL := all

.DELETE_ON_ERROR:

#
# Use $(space) for embedding a space in a list of (space-separated) tokens
#
empty :=
space := $(empty) $(empty)

#
# Use $(newline) for embedding a newline in text
#
define newline :=


endef

#
# Use $(comma) to denote a literal comma in function arguments
#
comma := ,

#
# $(windows) is non-empty when on Windows
#
windows := $(if $(findstring Windows,$(OS)),yes,)

#
# $(cygwin) is non-empty when under Cygwin.  We assume this is true
# when running cygwin make.
#
cygwin := $(if $(windows),$(if $(findstring cygwin,$(shell $(MAKE) --version)),yes))

#
# $(unix-like) is non-empty under vanilla Unix or Cygwin
#
unix-like := $(if $(windows),$(cygwin),yes)

#
# $(darwin) and $(freebsd) are non-empty when detected
#
uname-s := $(if $(unix-like),$(shell uname -s))
darwin := $(if $(filter darwin% Darwin%,$(uname-s)),yes)
freebsd := $(if $(filter freeBSD% FreeBSD%,$(uname-s)),yes)

#
# $(dev-null) is the name of the system bitbucket
#
dev-null := $(if $(unix-like),/dev/null,NUL)

#
# shell filesystem commands
#
copy := $(if $(unix-like),cp,copy /Y)
mkdir := $(if $(unix-like),mkdir -p,mkdir)
rmdir := $(if $(unix-like),rm -rf,-rmdir /S /Q)

#
# $(call escape,<path>)
#
# Converts each <space> in path to <backslash><space>
#
escape = $(subst $(space),\$(space),$1)

#
# $(call unescape,<path>)
#
# Converts each <backslash><space> in path to <space>
#
unescape = $(subst \$(space),$(space),$1)

#
# $(call to-make,<path>)
#
# Converts a path passed on the command line to one understood by make
# (backslashes mapped to slashes, spaces escaped by backslashes)
#
to-make = $(call escape,$(subst \,/,$1))

#
# $(call to-shell,<path>)
#
# Converts a make-style <path> to a path for the shell.
#
to-shell = $(if $(unix-like),$(call unescape,$1),$(subst /,\,$(call unescape,$1)))

#
# $(call to-native,<path>)
#
# Converts a make-style path to a path for a native executable.
#
to-native = $(if $(cygwin),$(shell cygpath --windows "$(call to-shell,$1)"),$(call to-shell,$1))

#
# $(call find-files,<pattern> ...,<root> ...)
#
# Recursively lists all non-directories matching any <pattern>,
# starting from the <root> names.  Spaces in directory or file names
# mess things up.
#
find-files = $(strip \
  $(foreach name,$(wildcard $2), \
    $(if $(wildcard $(name)/.), \
      $(call find-files,$1,$(patsubst %/,%,$(name))/*), \
      $(filter $1,$(patsubst ./%,%,$(name))) \
    ) \
  ) \
)

#
# $(call dependency-listing,<target> ...,<prerequisite file> ...)
#
# Returns the text for a dependency makefile, where each <target>
# depends on each <prerequisite file>.  A missing prerequisite file
# (without a recipe) causes make to think each <target> is out of
# date.
#
define dependency-listing =
$1: $2

$(subst $(space),,$(addsuffix :$(newline),$2))
endef

#
# $(call is-in-tree,<path>,<root>)
#
# Returns non-empty if <path> is in the tree starting at <root>
#
is-in-tree = $(if $(filter $(patsubst %/,%,$(abspath $2))/%,$(patsubst %/,%,$(abspath $1))/),yes)

#
# $(call check-out-of-tree,<path>,<root>)
#
check-out-of-tree = $(if $(call is-in-tree,$1,$2),$(error '$1' is in tree '$2'))

#
# $(call validate-build-setting,<name>,<allowed value>...,<default>)
# Returns a validated build settting
#
validate-build-setting = $(strip \
  $(if $($1), \
    $(if $(or $(word 2,$($1)),$(filter-out $2,$($1))), \
      $(error bad value '$($1)' for $1), \
      $($1) \
    ), \
    $3 \
  ) \
)
    
#
# Determine bjam-like build settings
#
override address-model :=\
  $(call validate-build-setting,address-model,32 64,64)
override address-sanitizer :=\
  $(call validate-build-setting,address-sanitizer,on norecover,)
override thread-sanitizer :=\
  $(call validate-build-setting,thread-sanitizer,on norecover,)
override toolset :=\
  $(call validate-build-setting,toolset,%,$(if $(windows),msvc,$(if $(or $(darwin),$(freebsd)),clang,gcc)))
override undefined-sanitizer :=\
  $(call validate-build-setting,undefined-sanitizer,on norecover,)
override variant :=\
  $(call validate-build-setting,variant,debug release,debug)

override build-settings := $(strip \
  address-model=$(address-model) \
  $(addprefix address-sanitizer=,$(address-sanitizer)) \
  $(addprefix thread-sanitizer=,$(thread-sanitizer)) \
  toolset=$(toolset) \
  $(addprefix undefined-sanitizer=,$(undefined-sanitizer)) \
  variant=$(variant) \
)

#
# Determine sanitizer flags for compiler command lines
#
sanitizer-keys := address thread undefined
sanitizer-flags := $(strip \
  $(foreach key,$(sanitizer-keys), \
    $(if $(filter on norecover,$($(key)-sanitizer)),-fsanitize=$(key)) \
  ) \
  $(addprefix -fno-sanitize-recover=, \
    $(subst $(space),$(comma),$(strip \
      $(foreach key,$(sanitizer-keys), \
        $(if $(filter norecover,$($(key)-sanitizer)),$(key)) \
      ) \
    )) \
  ) \
)

#
# Determine the name of the bjam executable, preferring 'b2' over 'bjam'
#
bjam := $(if $(shell b2 --version 2>$(dev-null)),b2,bjam)

#
# Determine the build directory
#
override build-dir := $(if $(build-dir),$(abspath $(call to-make,$(build-dir))),$(top-dir)/obj)

#
# Determine the (build setting-specific) directory for generated artifacts 
#
mode-dir := $(build-dir)/other/$(subst $(space),/,$(subst =,-,$(build-settings)))

#
# Determine the (build setting-specific) staging directory
#
stage-dir := $(mode-dir)/stage

#
# $(call project-work-dir,<project>)
# Returns the (build setting-specific) working directory for <project>
#
project-work-dir = $(mode-dir)/work/$1

#
# Determine the directory to install to
#
ifneq ($(filter install,$(MAKECMDGOALS)),)
  ifeq ($(install-dir),)
    $(error targets 'install' requires 'install-dir=<somehere>')
  endif
endif
install-dir := $(abspath $(call to-make,$(install-dir)))

#
# Determine bjam args; we assume bjam is a native executable
#
bjam-options := -sstage-dir="$(call to-native,$(stage-dir))"
bjam-options += --build-dir="$(call to-native,$(build-dir)/bjam)"
ifneq ($(install-dir),)
  bjam-options += --prefix="$(call to-native,$(install-dir))"
  ifneq ($(windows),)
    # Ensure dlls are placed in the directory for executables
    bjam-options += --libdir="$(call to-native,$(install-dir)/bin)"
  endif
endif

ifneq ($(verbose),)
  bjam-options += -d+2
endif

#
# $(call bjam_args, <bjam target>)
#
bjam_args = $(bjam-options) $(build-settings) $(patsubst %/,%,$(dir $1))$(addprefix //,$(basename $(notdir $1)))

#
# Rules for calling bjam
#

.PHONY: .phony
.phony: 

.bjam: .phony
	$(bjam) $(call bjam_args,$@)

%.bjam: .phony
	$(bjam) $(call bjam_args,$@)

