#
# "THE BEER-WARE LICENSE" (Revision CS-42):
#
# This file was written by the CodeShop developers.  As long as you
# retain this notice you can do whatever you want with it.
# If we meet some day, and you think this file is worth it, you can
# buy us a beer in return.  Even if you do that, this file still
# comes WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#

#
# Some common settings and utilities
#

DEFAULT_GOAL := all

.DELETE_ON_ERROR:

#
# Use $(space) for embedding a space in a list of (space-separated) tokens
#
empty :=
space := $(empty) $(empty)

#
# Use $(newline) for embedding a newline in text
#
define newline :=


endef

#
# $(windows) is non-empty when on Windows
#
windows := $(if $(findstring Windows,$(OS)),yes,)

#
# $(cygwin) is non-empty when under Cygwin.  We assume this is true
# when running cygwin make.
#
cygwin := $(if $(windows),$(if $(findstring cygwin,$(shell $(MAKE) --version)),yes))

#
# $(unix-like) is non-empty under vanilla Unix or Cygwin
#
unix-like := $(if $(windows),$(cygwin),yes)

#
# $(dev-null) is the name of the system bitbucket
#
dev-null := $(if $(unix-like),/dev/null,NUL)

#
# shell filesystem commands
#
copy := $(if $(unix-like),cp,copy /Y)
mkdir := $(if $(unix-like),mkdir -p,mkdir)
rmdir := $(if $(unix-like),rm -rf,-rmdir /S /Q)

#
# $(call escape,<path>)
#
# Converts each <space> in path to <backslash><space>
#
escape = $(subst $(space),\$(space),$1)

#
# $(call unescape,<path>)
#
# Converts each <backslash><space> in path to <space>
#
unescape = $(subst \$(space),$(space),$1)

#
# $(call to-make,<path>)
#
# Converts a path passed on the command line to one understood by make
# (backslashes mapped to slashes, spaces escaped by backslashes)
#
to-make = $(call escape,$(subst \,/,$1))

#
# $(call to-shell,<path>)
#
# Converts a make-style <path> to a path for the shell.
#
to-shell = $(if $(unix-like),$(call unescape,$1),$(subst /,\,$(call unescape,$1)))

#
# $(call to-native,<path>)
#
# Converts a make-style path to a path for a native executable.
#
to-native = $(if $(cygwin),$(shell cygpath --windows "$(call to-shell,$1)"),$(call to-shell,$1))

#
# $(release-build) and $(debug-build) test the value of $(variant);
# only one of these is true.  We default to a debug build.
#
release-build := $(if $(filter release,$(variant)),yes)
debug-build := $(if $(release-build),,yes)

#
# $(call find-files,<pattern> ...,<root> ...)
#
# Recursively lists all non-directories matching any <pattern>,
# starting from the <root> names.  Spaces in directory or file names
# mess things up.
#
find-files = $(strip \
  $(foreach name,$(wildcard $2), \
    $(if $(wildcard $(name)/.), \
      $(call find-files,$1,$(patsubst %/,%,$(name))/*), \
      $(filter $1,$(patsubst ./%,%,$(name))) \
    ) \
  ) \
)

#
# $(call dependency-listing,<target> ...,<prerequisite file> ...)
#
# Returns the text for a dependency makefile, where each <target>
# depends on each <prerequisite file>.  A missing prerequisite file
# (without a recipe) causes make to think each <target> is out of
# date.
#
define dependency-listing =
$1: $2

$(subst $(space),,$(addsuffix :$(newline),$2))
endef

#
# $(call is-in-tree,<path>,<root>)
#
# Returns non-empty if <path> is in the tree starting at <root>
#
is-in-tree = $(if $(filter $(patsubst %/,%,$(abspath $2))/%,$(patsubst %/,%,$(abspath $1))/),yes)

#
# $(call check-out-of-tree,<path>,<root>)
#
check-out-of-tree = $(if $(call is-in-tree,$1,$2),$(error '$1' is in tree '$2'))
