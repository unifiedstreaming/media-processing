#
# "THE BEER-WARE LICENSE" (Revision CS-42):
#
# This file was written by the CodeShop developers.  As long as you
# retain this notice you can do whatever you want with it.
# If we meet some day, and you think this file is worth it, you can
# buy us a beer in return.  Even if you do that, this file still
# comes WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#

#
# Some common settings and utilities
#

.DEFAULT_GOAL := all

.DELETE_ON_ERROR:
.SECONDEXPANSION:

#
# Use $(space) for embedding a space in a list of (space-separated) tokens
#
empty :=
space := $(empty) $(empty)

#
# Use $(newline) for embedding a newline in text
#
define newline :=


endef

#
# Use $(comma) to denote a literal comma in function arguments
#
comma := ,

#
# $(windows) is non-empty when on Windows
#
windows := $(if $(findstring Windows,$(OS)),yes,)

#
# $(cygwin) is non-empty when under Cygwin.  We assume this is true
# when running cygwin make.
#
cygwin := $(if $(windows),$(if $(findstring cygwin,$(shell $(MAKE) --version)),yes))

#
# $(unix-like) is non-empty under vanilla Unix or Cygwin
#
unix-like := $(if $(windows),$(cygwin),yes)

#
# $(darwin) and $(freebsd) are non-empty when detected
#
uname-s := $(if $(unix-like),$(shell uname -s))
darwin := $(if $(filter darwin% Darwin%,$(uname-s)),yes)
freebsd := $(if $(filter freeBSD% FreeBSD%,$(uname-s)),yes)

#
# $(dev-null) is the name of the system bitbucket
#
dev-null := $(if $(unix-like),/dev/null,NUL)

#
# shell filesystem commands
#
copy := $(if $(unix-like),cp,copy /Y)
mkdir := $(if $(unix-like),mkdir -p,mkdir)
rmdir := $(if $(unix-like),rm -rf,-rmdir /S /Q)
move := $(if $(unix-like),mv -f,move)

#
# $(call escape,<path>)
#
# Converts each <space> in path to <backslash><space>
#
escape = $(subst $(space),\$(space),$1)

#
# $(call unescape,<path>)
#
# Converts each <backslash><space> in path to <space>
#
unescape = $(subst \$(space),$(space),$1)

#
# $(call to-make,<path>)
#
# Converts a path passed on the command line to one understood by make
# (backslashes mapped to slashes, spaces escaped by backslashes)
#
to-make = $(call escape,$(subst \,/,$1))

#
# $(call to-shell,<path>)
#
# Converts a make-style <path> to a path for the shell.
#
to-shell = $(if $(unix-like),$(call unescape,$1),$(subst /,\,$(call unescape,$1)))

#
# $(call to-native,<path>)
#
# Converts a make-style path to a path for a native executable.
#
to-native = $(if $(cygwin),$(shell cygpath --windows "$(call to-shell,$1)"),$(call to-shell,$1))

#
# $(call find-files,<pattern>*,<root>*)
#
# Recursively lists all non-directories matching any <pattern>,
# starting from the <root> names.  Spaces in directory or file names
# mess things up.
#
find-files = $(strip \
  $(foreach name,$(wildcard $2), \
    $(if $(wildcard $(name)/.), \
      $(call find-files,$1,$(patsubst %/,%,$(name))/*), \
      $(filter $1,$(patsubst ./%,%,$(name))) \
    ) \
  ) \
)

#
# $(call dependency-listing,<target> ...,<prerequisite file> ...)
#
# Returns the text for a dependency makefile, where each <target>
# depends on each <prerequisite file>.  A missing prerequisite file
# (without a recipe) causes make to think each <target> is out of
# date.
#
define dependency-listing =
$1: $2

$(subst $(space),,$(addsuffix :$(newline),$2))
endef

#
# $(call is-in-tree,<path>,<root>)
#
# Returns non-empty if <path> is in the tree starting at <root>
#
is-in-tree = $(if $(filter $(patsubst %/,%,$(abspath $2))/%,$(patsubst %/,%,$(abspath $1))/),yes)

#
# $(call check-out-of-tree,<path>,<root>)
#
check-out-of-tree = $(if $(call is-in-tree,$1,$2),$(error '$1' is in tree '$2'))

#
# $(call validate-build-setting,<name>,<allowed value>...,<default>)
# Returns a validated build settting
#
validate-build-setting = $(strip \
  $(if $($1), \
    $(if $(or $(word 2,$($1)),$(filter-out $2,$($1))), \
      $(error bad value '$($1)' for $1), \
      $($1) \
    ), \
    $3 \
  ) \
)
    
#
# Determine bjam-like build settings
#
override address-model :=\
  $(call validate-build-setting,address-model,32 64,64)
override address-sanitizer :=\
  $(call validate-build-setting,address-sanitizer,on norecover,)
override thread-sanitizer :=\
  $(call validate-build-setting,thread-sanitizer,on norecover,)
override toolset :=\
  $(call validate-build-setting,toolset,%,$(if $(windows),msvc,$(if $(or $(darwin),$(freebsd)),clang,gcc)))
override undefined-sanitizer :=\
  $(call validate-build-setting,undefined-sanitizer,on norecover,)
override variant :=\
  $(call validate-build-setting,variant,debug release,debug)

override build-settings := $(strip \
  address-model=$(address-model) \
  $(addprefix address-sanitizer=,$(address-sanitizer)) \
  $(addprefix thread-sanitizer=,$(thread-sanitizer)) \
  toolset=$(toolset) \
  $(addprefix undefined-sanitizer=,$(undefined-sanitizer)) \
  variant=$(variant) \
)

#
# Determine sanitizer flags for compiler command lines
#
sanitizer-keys := address thread undefined
sanitizer-flags := $(strip \
  $(foreach key,$(sanitizer-keys), \
    $(if $(filter on norecover,$($(key)-sanitizer)),-fsanitize=$(key)) \
  ) \
  $(addprefix -fno-sanitize-recover=, \
    $(subst $(space),$(comma),$(strip \
      $(foreach key,$(sanitizer-keys), \
        $(if $(filter norecover,$($(key)-sanitizer)),$(key)) \
      ) \
    )) \
  ) \
)

#
# Determine the name of the bjam executable, preferring 'b2' over 'bjam'
#
bjam := $(if $(shell b2 --version 2>$(dev-null)),b2,bjam)

#
# $(call staged-jamfile-content,<library name>,<library file>,<include directory>)
# Generates the content of a jamfile for consuming a library.
#
define staged-jamfile-content =
lib $1
:
:
<file>"$(subst \,/,$(call to-native,$2))"
:
:
<include>"$(subst \,/,$(call to-native,$3))"
;

endef

#
# $(call is-absolute,<path>)
#
is-absolute = $(strip \
  $(if $(firstword $1), \
    $(if $(filter $(abspath $(firstword $1)),$(firstword $1)),yes) \
  ) \
)

#
# $(call check-absolute,<path>)
#
check-absolute = $(if $(call is-absolute,$1),$1,$(error '$1' is not an absolute path))

#
# establish dest-dir
#
override dest-dir := $(if $(dest-dir),$(call to-make,$(call check-absolute,$(subst \,/,$(dest-dir)))))

#
# $(call required-value,<name>)
#
required-value = $(if $($1),$($1),$(error '$1' must be be set))

#
# $(call keep-last-instance,<word>*)
#
keep-last-instance-impl = $(if $(firstword $1), \
  $(if $(filter $(firstword $1),$(wordlist 2,$(words $1),$1)), \
    , \
    $(firstword $1) \
  ) \
  $(call keep-last-instance-impl,$(wordlist 2,$(words $1),$1)) \
)

keep-last-instance = $(strip $(call keep-last-instance-impl,$1))

