#
# "THE BEER-WARE LICENSE" (Revision CS-42):
#
# This file was written by the CodeShop developers.  As long as you
# retain this notice you can do whatever you want with it.
# If we meet some day, and you think this file is worth it, you can
# buy us a beer in return.  Even if you do that, this file still
# comes WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#

#
# $(call check-prereqs,<project>,<depending project*>)
#
# Checks the prerequisites of a project.
#
check-prereqs = $(strip \
  $(foreach pre,$($1.prereqs), \
    \
    $(call REM,check if prereq exists) \
    $(if $(filter-out $(all-projects),$(pre)), \
      $(error prerequisite project '$(pre)' in project '$1' not found) \
    ) \
    \
    $(call REM,check for project dependency cycles) \
    $(if $(filter $1 $2,$(pre)), \
      $(error $(strip \
        project cycle in project prereq chain \
        $(foreach proj,$(call reverse,$1 $2), \
          '$(proj)' -> \
        ) \
        '$(pre)' \
      )) \
    ) \
    \
    $(call REM,remove prereq from all-leaf-projects) \
    $(eval all-leaf-projects := $(filter-out $(pre),$(all-leaf-projects))) \
    \
    $(call REM,recurse over prereq) \
    $(call check-prereqs,$(pre),$(strip $1 $2)) \
  ) \
)
      
#
# $(call proj-with-pkg,<project>)
#
# For error reporting purposes.
#
proj-with-pkg = $(strip \
  '$1' \
  $(if $($1.package), \
    $(open-paren)package: '$($1.package)'$(close-paren) \
  ) \
)

#
# $(call is-prereq,<project>,<of project>*)
#
# Tells if <project> is a prereq of any project in <of project>*.
#
is-prereq = $(strip \
  $(if $(firstword $2), \
    $(if $(filter $(foreach of,$2,$($(of).prereqs)),$1), \
      $(call REM,direct prereq found) \
      yes \
    , \
      $(call REM,check the prereqs' prereqs) \
      $(call is-prereq,$1,$(foreach of,$2,$($(of).prereqs))) \
    ) \
  ) \
)
    
#
# $(call contains-prereq,<project>*,<of project>)
#
# Tells if a list of projects contains a prereq of some other project
#
contains-prereq = $(strip \
  $(if $(firstword $1), \
    $(if $(call is-prereq,$(firstword $1),$2), \
      $(call REM,prereq found at head of list) \
      yes \
    , \
      \
      $(call REM,check rest of list) \
      $(call contains-prereq,$(wordlist 2,$(words $1),$1),$2) \
    ) \
  ) \
)

#
# $(call remove-depending,<project *>,<on project>)
#
# Returns a new list of projects with projects depending on some
# specific project removed
#
remove-depending = $(strip \
  $(foreach proj,$1, \
    $(if $(call is-prereq,$2,$(proj)), \
      $(call REM,skip proj) \
    , \
      $(call REM,keep proj) \
      $(proj) \
    ) \
  ) \
)

#
# $(call add-packager,<packager *>,<new packager>)
#
# Adds a packager to a set of potential packagers for a project,
# returning the new set.
#
add-packager = $(strip \
  $(if $(filter $1,$2), \
    $(call REM,already there so return old set) \
    $1 \
  , \
    $(if $(call contains-prereq,$1,$2), \
      $(call REM,prereqs take priority so return old set) \
      $1 \
    , \
      $(call REM,add after removing any depending packagers from set) \
      $2 $(call remove-depending,$1,$2) \
    ) \
  ) \
)

#
# $(call add-packagers,<project>,<depending project>*,<packager>?)
#
# Sets the potential packagers for <project> and its prereqs.
#
add-packagers = $(strip \
  $(if $($1.distributable), \
    $(call REM,only distributables can be packaged) \
    $(if $($1.package), \
      $(call REM,project is its own packager) \
      $(if $(filter-out $(all-packages),$($1.package)), \
        $(call REM,package not found) \
        $(error $(strip \
          project '$1': package '$($1.package)' not found \
        )) \
      ) \
      $(if $(filter-out $($3.package),$($1.package)), \
        $(call REM,entering another package) \
        $(if $(filter $(foreach dep,$2,$($(dep).package)),$($1.package)), \
          $(call REM,re-entering previously visited package) \
          $(error $(strip \
            package cycle in project prereq chain \
            $(foreach proj,$(call reverse,$2), \
              $(call proj-with-pkg,$(proj)) -> \
            ) \
            $(call proj-with-pkg,$1) \
          )) \
        ) \
      ) \
      $(eval $1.packagers := $1) \
    , \
      $(call REM,add depending packager if available) \
      $(if $(strip $3), \
        $(eval $1.packagers := $(call add-packager,$($1.packagers),$3)) \
      ) \
    ) \
  , \
    $(call REM,not distributable) \
    $(if $($1.package), \
      $(error $(strip \
        project '$1' cannot have a package because it is not distributable \
      )) \
    ) \
    $(eval $1.packagers :=) \
  ) \
  \
  $(call REM,visit prereqs) \
  $(foreach pre,$($1.prereqs), \
    $(call add-packagers,$(pre),$(strip $1 $2),$(if $($1.package),$1,$3)) \
  ) \
)

#
# $(call potential-packages,<project>)
#
# Gets the potential packages for <project> by fetching the package names
# from its packagers.
#
potential-packages = $(strip \
  $(call dedup,$(foreach pkgr,$($1.packagers),$($(pkgr).package))) \
)

#
# $(call set-package-impl,<project>,<potential package*>)
#
set-package-impl = $(strip \
  $(if $(filter 0,$(words $2)), \
    $(call REM,no package) \
    $(eval $1.package :=) \
  , \
    $(if $(filter 1,$(words $2)), \
      $(call REM,single package) \
      $(eval $1.package := $(firstword $2)) \
    , \
      $(call REM,multiple packages) \
      $(error $(strip \
        cannot implicitly determine the package for project '$1' because \
        not all packaged projects depending on this project \
        [$(foreach pkgr,$($1.packagers),$(call proj-with-pkg,$(pkgr)))] \
        are in the same package \
      )) \
    ) \
  ) \
)

#
# $(call set-package,<project>)
#
set-package = $(call set-package-impl,$1,$(call potential-packages,$1))

#
# $(call projects-in-package,<package>)
#
projects-in-package = $(strip \
  $(foreach proj,$(all-projects), \
    $(if $(filter $1,$($(proj).package)), \
      $(proj) \
    ) \
  ) \
)

#
# $(call prereq-packages-impl,<root package>,<project>*)
#
prereq-packages-impl = $(strip \
  $(call dedup, \
    $(foreach prj,$2, \
      $(filter-out $1,$($(prj).package)) \
      $(call prereq-packages-impl,$1,$($(prj).prereqs)) \
    ) \
  ) \
)

#
# $(call prereq-packages,<package>)
#
prereq-packages = $(strip \
  $(call prereq-packages-impl,$1,$(call projects-in-package,$1)) \
)

#
# $(call native-packager-settings,<project>)
#
native-packager-settings = $(strip \
  $(build-settings) \
  package=$1 \
  license="$($1.package-license)" \
  prereq-packages="$(call prereq-packages,$1)" \
  artifacts-dir="$(call to-shell,$(artifacts-dir))" \
  packaging-work-dir="$(call to-shell,$(packaging-work-dir))" \
  service-files="$(foreach f,$($1.package-service-files),$(call non-relative-path,$f))" \
  openrc-files="$(foreach f,$($1.package-openrc-files),$(call non-relative-path,$f))" \
)

#
# $(call doc-artifacts-dir,<package>)
#
doc-artifacts-dir = $(artifacts-dir)/$1/doc/$1$(build-settings-suffix)

#
# $(call doc-artifact,<package>,<source file>)
#
doc-artifact = $(call doc-artifacts-dir,$1)/$(notdir $(call drop-template-suffix,$2))

#
# $(call conf-artifacts-dir,<package>)
#
conf-artifacts-dir = $(artifacts-dir)/$1/etc

#
# $(call conf-artifact,<package>,<template file>)
#
conf-artifact = $(call conf-artifacts-dir,$1)/$(call notdir-basename,$(call drop-template-suffix,$2))$(build-settings-suffix)$(suffix $(call drop-template-suffix,$2))

#
# $(call artifact-targets,<package>)
#
define artifact-targets =
#
# distributable artifact targets for package $1
#
$(artifacts-dir)/$1: | $(artifacts-dir)
	$(usp-mkdir-p) "$$(call to-shell,$$@)"

$(call doc-artifacts-dir,$1): | $(artifacts-dir)/$1
	$(usp-mkdir-p) "$$(call to-shell,$$@)"
	
$(call conf-artifacts-dir,$1): | $(artifacts-dir)/$1
	$(usp-mkdir-p) "$$(call to-shell,$$@)"
	
$(foreach prj,$(call projects-in-package,$1),$(prj).project-artifacts: | $(artifacts-dir)/$1$(newline))

.PHONY: $1.artifacts
$1.artifacts: $(strip $(foreach pkg,$(call prereq-packages,$1),$(pkg).artifacts) $(foreach prj,$(call projects-in-package,$1),$(prj).project-artifacts) $(foreach df,$($1.package-doc-files),$(call doc-artifact,$1,$(df))) $(foreach cf,$($1.package-conf-files),$(call conf-artifact,$1,$(cf))))

$(foreach df,$($1.package-doc-files),$(call doc-artifact,$1,$(df)): $(df) | $(call doc-artifacts-dir,$1)$(newline)$(tab)$(call subst-or-copy,$(df),$(call doc-artifact,$1,$(df)))$(newline)$(newline))

$(foreach cf,$($1.package-conf-files),$(call conf-artifact,$1,$(cf)): $(cf) | $(call conf-artifacts-dir,$1)$(newline)$(tab)$(call subst-or-copy,$(cf),$(call conf-artifact,$1,$(cf)))$(newline)$(newline))

.PHONY: $1.deb-package
$1.deb-package: $(strip $(foreach pkg,$(call prereq-packages,$1),$(pkg).deb-package) $1.artifacts)
	$$(MAKE) -I $(usp-builder-include-dir) -f $(usp-builder-lib-dir)/DebPackage.mak $(call native-packager-settings,$1) deb-package

.PHONY: $1.rpm-package
$1.rpm-package: $(strip $(foreach pkg,$(call prereq-packages,$1),$(pkg).rpm-package) $1.artifacts)
	$$(MAKE) -I $(usp-builder-include-dir) -f $(usp-builder-lib-dir)/RpmPackage.mak $(call native-packager-settings,$1) rpm-package

.PHONY: $1.apk-package
$1.apk-package: $(strip $(foreach pkg,$(call prereq-packages,$1),$(pkg).apk-package) $1.artifacts)
	$$(MAKE) -I $(usp-builder-include-dir) -f $(usp-builder-lib-dir)/ApkPackage.mak $(call native-packager-settings,$1) apk-package

.PHONY: $1.zip-file
$1.zip-file: $(strip $(foreach pkg,$(call prereq-packages,$1),$(pkg).zip-file) $1.artifacts)
	$$(MAKE) -I $(usp-builder-include-dir) -f $(usp-builder-lib-dir)/ZipFile.mak $(call native-packager-settings,$1) zip-file

.PHONY: $1.clean-artifacts
$1.clean-artifacts:
	$(usp-rm-rf) "$$(call to-shell,$(artifacts-dir)/$1)"

endef

#
# Check the prerequisites for all projects, so we know they form
# a proper dependency DAG without dangling project references.
# As a side effect, prerequisite projects are filtered out of
# $(all-leaf-projects).
#
all-leaf-projects := $(all-projects)
$(foreach proj,$(all-projects),$(call check-prereqs,$(proj)))

#
# Starting from the leaf projects in the tree, for each project,
# establish a list of (zero or more) packagers while removing
# packagers that depend on one of the project's other packagers.  (A
# packager is a project with an explicit 'package' attribute.)
#
$(foreach proj,$(all-projects),$(eval $(proj).packagers :=))
$(foreach proj,$(all-leaf-projects),$(call add-packagers,$(proj)))

#
# For each project, determine the package it is in (if any) by
# inspecting its list of packagers.
#
$(foreach proj,$(all-projects),$(call set-package,$(proj)))

#
# Define artifact targets for all packages
#
$(strip \
  $(foreach pkg,$(all-packages), \
    $(call expand,$(call artifact-targets,$(pkg))) \
  ) \
)

.PHONY: all.artifacts
all.artifacts: $(foreach pkg,$(all-packages),$(pkg).artifacts) 

.PHONY: all.deb-package
all.deb-package: $(foreach pkg,$(all-packages),$(pkg).deb-package) 

.PHONY: all.rpm-package
all.rpm-package: $(foreach pkg,$(all-packages),$(pkg).rpm-package) 

.PHONY: all.apk-package
all.apk-package: $(foreach pkg,$(all-packages),$(pkg).apk-package) 

.PHONY: all.zip-file
all.zip-file: $(foreach pkg,$(all-packages),$(pkg).zip-file) 

.PHONY: all.clean-artifacts
all.clean-artifacts:
	$(foreach f,$(wildcard $(artifacts-dir)/*),$(usp-rm-rf) "$(call to-shell,$f)"$(newline))

PHONY: clean
clean:
	$(usp-rm-rf) "$(call to-shell,$(build-dir))"
